# Back-end Java EE and Angular Front-end

It was based in the course of Antonio Goncalves of Pluralsight platform. It is seppareted into 2 peaceas, back-end and front-end.

## Generating maven archetype

[class 15] It was generated by IntelliJ IDE, but it could be done by the command line using [the following](https://maven.apache.org/archetype/maven-archetype-plugin/examples/generate-batch.html):

           mvn archetype:generate -B -DarchetypeGroupId=org.codehaus.mojo.archetypes -DarchetypeArtifactId=stockstore-back -DarchetypeVersion=1.1 -DgroupId=com.salesapp.javaee-angular -Dversion=1.0 -Dpackage=com.salesapp.backend

## Postgres and JPA

It is within Model as part of the Domain Model, where is described the business, in Java it is incapsulated in an object that incorporates behavior and data and it is defined by the Nouns of the domain, that is the product class. The postgres is used by the means of JPA and [configured postgres by a property file](https://www.callicoder.com/spring-boot-jpa-hibernate-postgresql-restful-crud-api-example/). Object Relational Mapping is the way that brings database and object together, considering that object only is available when JVM is running, so garbage collect cleans the memory when JVM stops, and the object disappear, but the data of the object needs to be persisted, so it is stored in relational databases (postgres in this project) and ORM has the main objective delegates to an external tool that in Java is called Java Persistence API (JPA) that maps objects to a relational database and on it persistent objects are called entities and CRUD's operations are executed by an entity manager that comes with more powerful Query language JPQL (Java Persistence Query Language). But there is a difference between entity and object that is it lives persistently in database, not just in memory like the object does. It uses JDBC underneath, but removes its boilerplate code. JPA uses metadata that is extra data.

So it is used @Entity annotation to indicate to JPA, @GeneratedValue generates index in the field in the database, @Column(name"field_name") where name is the name that will be generated for the column at the database. @Temporal(TemporalType.DATE) is used to save the data in database as a date format, not as a timestamp zone.

As JavaEE specification, JPA uses a xml file for configure, named Deployment Descriptor. In the tag persistence is specified  the unit name that is used by the entity manager. Properties as schema-generation is defined as well, that can define for example action drop and create that is applied each time the application is redeployed. As the database is not H2, but postgres, so we need to add some extra lines in the property file according to the [JPA Tutorial](https://thorben-janssen.com/jpa-persistence-xml/), so tags like provider, jta data source and other as hibernate to specify transaction, dialect, format and some other. Before that, it is needed to add Postgres, JPA and Hibernate dependency at the POM xml file. 

In practice, to generate the xml persistence file and save some time, it can be used the wizard tool from IntelliJ at Project Structure screen (ctrl + alt + shift + s) -> modules, there's the option JPA, selecting it will show on the right side a plus sign, so choose persistence.xml option and in the path field, specify this: src\main\resources\META-INF\persistence.xml, and some content is auto generated. [class 20]

After that, it is time to create a unit persistence (View > Tool window > Persistence), right button upon the project name > new > Persistence Unit and give a name (used stockStorePU). Then, right button upon the persistence unit created > new > Entity, give the name (product) and choose the package, adding a dot, and the new folder model. A tag name persistence-unit is added automatically, as another one called class as well, so specify fields it should have.

Some Property tags are needed also persistence, as said before, create and drop lines were added and the ddl file is generated when running the application with payara and we can see it at the path: C:\payara5\glassfish\domains\domain1\config. In the wildfly the folder is at the path: C:\DevTools\wildfly-10.1.0.Final\bin. [class 20]

A Repository stays between the domain and the data layer (relational database). In the repository file, annotations are used as the same way in the class to interact with JPA. [class 24]
    * @PersistenceContext(unitName = "stockStorePU")

JPQL (Java Persistence Query Language) is used to perform searches against entities no matter what is the underlying database. The main difference to the SQL root is that this one retrieves rows and columns, while JPQL uses entities or collections of it, and it is object-oriented and therefore easily understood by devs. Its syntax consists in select clause and from clause, optionally uses where, order by, group by, having...as well <function> AVG, COUNT, MAX, MIN, SUM..., used in [findAll and countAll methods](src/main/java/com/salesapp/backend/repository/ProductRepository.java) [classes 25/26]

JTA (Java Transaction API) is responsible to start commit and rollback transactions, and because managing this questions is highly complex task, JTA gives us high level API, in which we need just to use annotations (@Transactional). If we try to save a product (for instance), we would have an exception without specifying a [transaction annotation](https://www.alura.com.br/artigos/jta-java-transaction-api). So using argument SUPPORTS (good for READONLY) for instance, it means that the method can be used with or without an active transaction, for example, a method can be used within a transaction for a specific situation, but for another call, it doesn't. SUPPORTS would be used for find, findAll, and countAll (readonly methods), but it is wise to put directly to all class  REQUIRED (used in [create and delete methods](src/main/java/com/salesapp/backend/repository/ProductRepository.java) because they allows just data) means is used to say if a transaction exists, so it is not started a new one, but if doesn't, it is started (mostly common used). [classes 27/28]

## Payara Server

- Download payara full server, version 5.184, from [Maven Central Repo](https://search.maven.org/search?q=g:fish.payara.distributions%20AND%20a:payara&core=gav).
- In IntelliJ Idea, open Edit configurations and add a new GLASSFISH LOCAL configuration.
- In Application Server field, choose CONFIGURE and select the folder where payara server was downloaded previously.
- (CHOOSE THE FOLDER NAMED Payara5).
- Choose DOMAIN1 in Server Domain field.

It was not possible to run arquillian with payara easily, so it was decided to use wildfly, as described bellow. [class 12, 16]

### Accessing Server Page

It can be reached by going to the localhost:4848.

## WildFly

It was installed the 10.1.0.Final version of [the wildfly](https://www.wildfly.org/downloads/). Accessing the localhost instance it is possible to create a user after running standalone version described at the README.txt that comes with the zip file downloaded. [class 12]

There was a problem when building that error was "cannot be cast to org.dom4j.DocumentFactory" and after lots of hours searching, I tried some options to put in the persistence.xml that was found at [a forum](https://forum.hibernate.org/viewtopic.php?f=9&t=1044271&view=previous) almost at the end of the pager where the guy shows his configuration hibernate, then I tried 2 of them: 

      <property name="jboss.as.jpa.providerModule" value="application" />
      <property name="hibernate.transaction.jta.platform"
                value="org.hibernate.service.jta.platform.internal.JBossAppServerJtaPlatform"/>

and I added the provider tag:

    <provider>org.hibernate.jpa.HibernatePersistenceProvider</provider>

Another detail is that I used war exploded for artifact in the WildFly server configuration. The course doesn't treat about setting up the server, just show when already running, so I needed to find by myself in the web and [some of them helped me](https://www.youtube.com/watch?v=U23lx1cJyrQ).  

## Testing code

Taking the ProductRepository for instance, the create method more specifically, when  entityManager.persist method is executed, it will throw the null point exception, so it would need arquillian (create a container to test) and shrinkWrap (make injection happens) or something to solve this, but for now it not the focus.

It was created a test class and specified additional framework following instruction by the [article from jetbrains about aquillian](https://www.jetbrains.com/help/idea/arquillian.html#creating-a-test-class). The beans.xml wasn't added by this tutorial, but about the one mentioned on this Readme bellow, despite it has a part to treat about this. 

There was a problem when trying to download the jar file for arquillian-glassfish, so I needed to make it different than instructed at the article above, adding it to the POM file and after choosing in the existing libraries. But this solution didn't work for this project, so I tried the one showed in the [class 32] and based in some instructions from [payara blog about arquillian](https://blog.payara.fish/how-to-test-applications-with-payara-server-micro-with-arquillian), it was used payara server managed.

At the first time arquillian test was run, it failed because it is necessary to add the product class to the ShrinkWrap to insert it to the archive.

## Constraints - Bean Validation

It can be used in all the Java EE components, passing data and if this is a not valid data, it will throw an exception. Defines a set of constraints, using annotations. So @NotNull, @Size with min and max (instead of just @Column), @Past are examples of some constraints we can use, in both [Product class](src/main/java/com/salesapp/backend/model/Product.java) and [Product repository](src/main/java/com/salesapp/backend/repository/ProductRepository.java). This way is avoided if's and else's to validate business rules. [Class 37 not implemented yet because arquillian and shrinkWrap is not ready because of job matters priorities]

## Utility classes

It is used to manage dependencies between components in Java EE and it is not needed to use Java constructor to create new instances of this components, but it is used Context and Dependency Injection (CDI), which is a dedicated Java EE service to manage injection [Classes 37/39]. It uses annotation to get an object reference and allow us to rely on external component, loosing coupling.

Bean is an object that is managed by Java EE runtime container and most objects on it are beans, except for JPA Entities. The difference between class and bean is that it has extra services given by the container to a bean, like life cycle management, interception, injection, decorators, events and contents managements. The ProductRepository class is considered a bean because uses Injection, that is logic business that makes interactions with modules, user interfaces, external API's... in the application. Beans depend on other beans, but they don't create their own dependencies, but delegate to a container, what is called inversion of control, the control of choosing the dependency is inverted because it is given to an external container. CDI stands on the concepts of Loose coupling, strong typing, which beans are settled. So container injects bean's references into other beans, but CDI does more than injection and it is necessary to go deeper to understand it.

ProductRepository is a bean that creates that defines methods to create a product. Creating external methods to generate Id product or sanitize title in a textutil class (both with no special annotation or super class implements), it is indicated by @Inject annotation.

Beans to work properly needs to have a xml file (deployment descriptor) with just a bean-discovery-mode =  all that is responsible to inform to CDI to discovery all beans of the application [class 41].

Applying so, going to the ProductRepository, it is injected the textutil class, so this way it is possible to be used before persisting the title to the database for instance, but it to work needs firstly to be added the xml file said above (deployment descriptor), and an automated way to do it is to use IDE resource, alt + insert, typing xml and choosing beans.xlm, leaving it empty just with default specifications that contains discovery all. [class 42 - observe the need of shrinkwrap specification for textutil to not give an exception in the test - 03:07 min time]
