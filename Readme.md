#Back-end Java EE and Angular Front-end

It was based in the course of Antonio Goncalves of Pluralsight platform.

## Generating maven archetype

[class 15] It was generated by IntelliJ IDE, but it could be done by the command line using [the following](https://maven.apache.org/archetype/maven-archetype-plugin/examples/generate-batch.html):

            mvn archetype:generate -B -DarchetypeGroupId=org.codehaus.mojo.archetypes -DarchetypeArtifactId=stockstore-back -DarchetypeVersion=1.1 -DgroupId=com.salesapp.javaee-angular -Dversion=1.0 -Dpackage=com.salesapp.backend

## Postgres and JPA

It is within Model as part of the Domain Model, where is described the business, in Java it is incapsulated in an object that incorporates behavior and data and it is defined by the Nouns of the domain, that is the product class. The postgres is used by the means of JPA and [configured postgres by a property file](https://www.callicoder.com/spring-boot-jpa-hibernate-postgresql-restful-crud-api-example/). Object Relational Mapping is the way that brings database and object together, considering that object only is available when JVM is running, so garbage collect cleans the memory when JVM stops, and the object disappear, but the data of the object needs to be persisted, so it is stored in relational databases (postgres in this project) and ORM has the main objective delegates to an external tool that in Java is called Java Persistence API (JPA) that maps objects to a relational database and on it persistent objects are called entities and CRUD's operations are executed by an entity manager that comes with more powerful Query language JPQL (Java Persistence Query Language). But there is a difference between entity and object that is it lives persistently in database, not just in memory like the object does. It uses JDBC underneath, but removes its boilerplate code. JPA uses metadata that is extra data.

So it is used @Entity annotation to indicate to JPA, @GeneratedValue generates index in the field in the database, @Column(name"field_name") where name is the name that will be generated for the column at the database. @Temporal(TemporalType.DATE) is used to save the data in database as a date format, not as a timestamp zone.

As JavaEE specification, JPA uses a xml file for configure, named Deployment Descriptor. In the tag persistence is specified  the unit name that is used by the entity manager. Properties as schema-generation is defined as well, that can define for example action drop and create that is applied each time the application is redeployed. As the database is not H2, but postgres, so we need to add some extra lines in the property file according to the [JPA Tutorial](https://thorben-janssen.com/jpa-persistence-xml/), so tags like provider, jta data source and other as hibernate to specify transaction, dialect, format and some other. Before that, it is needed to add Postgres, JPA and Hibernate dependency at the POM xml file. 

In practice, to generate the xml persistence file and save some time, it can be used the wizard tool from IntelliJ at Project Structure screen (ctrl + alt + shift + s) -> modules, there's the option JPA, selecting it will show on the right side a plus sign, so choose persistence.xml option and in the path field, specify this: src\main\resources\META-INF\persistence.xml, and some content is auto generated.

After that, it is time to create a unit persistence (View > Tool window > Persistence), right button upon the project name > new > Persistence Unit and give a name (used stockStorePU). Then, right button upon the persistence unit created > new > Entity, give the name (product) and choose the package, adding a dot, and the new folder model. A tag name persistence-unit is added automatically, as another one called class as well, so specify fields it should have.

Some Property tags are needed also persistence, as said before, create and drop lines were added and the ddl file is gererated when running the application with payara and we can see it at the path: C:\payara5\glassfish\domains\domain1\config.

## Payara Server

- Download payara full server, version 5.184, from [Maven Central Repo](https://search.maven.org/search?q=g:fish.payara.distributions%20AND%20a:payara&core=gav).
- In IntelliJ Idea, open Edit configurations and add a new GLASSFISH LOCAL configuration.
- In Application Server field, choose CONFIGURE and select the folder where payara server was downloaded previously.
- (CHOOSE THE FOLDER NAMED Payara5).
- Choose DOMAIN1 in Server Domain field.
 
    ### Accessing Server Page

It can be reached by going to the 
